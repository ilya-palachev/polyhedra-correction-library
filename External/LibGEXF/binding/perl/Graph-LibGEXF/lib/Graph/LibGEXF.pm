# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package Graph::LibGEXF;
use base qw(Exporter);
use base qw(DynaLoader);
package Graph::LibGEXFc;
bootstrap Graph::LibGEXF;
package Graph::LibGEXF;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Graph::LibGEXF;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Graph::LibGEXF;


############# Class : Graph::LibGEXF::vectors ##############

package Graph::LibGEXF::vectors;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_vectors(@_);
    bless $self, $pkg if defined($self);
}

*size = *Graph::LibGEXFc::vectors_size;
*empty = *Graph::LibGEXFc::vectors_empty;
*clear = *Graph::LibGEXFc::vectors_clear;
*push = *Graph::LibGEXFc::vectors_push;
*pop = *Graph::LibGEXFc::vectors_pop;
*get = *Graph::LibGEXFc::vectors_get;
*set = *Graph::LibGEXFc::vectors_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_vectors($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::ReadLockException ##############

package Graph::LibGEXF::ReadLockException;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_ReadLockException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_ReadLockException($self);
        delete $OWNER{$self};
    }
}

*what = *Graph::LibGEXFc::ReadLockException_what;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::WriteLockException ##############

package Graph::LibGEXF::WriteLockException;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_WriteLockException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_WriteLockException($self);
        delete $OWNER{$self};
    }
}

*what = *Graph::LibGEXFc::WriteLockException_what;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::FileWriterException ##############

package Graph::LibGEXF::FileWriterException;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_FileWriterException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_FileWriterException($self);
        delete $OWNER{$self};
    }
}

*what = *Graph::LibGEXFc::FileWriterException_what;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::FileReaderException ##############

package Graph::LibGEXF::FileReaderException;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_FileReaderException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_FileReaderException($self);
        delete $OWNER{$self};
    }
}

*what = *Graph::LibGEXFc::FileReaderException_what;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::GEXF ##############

package Graph::LibGEXF::GEXF;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_GEXF(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_GEXF($self);
        delete $OWNER{$self};
    }
}

*getUndirectedGraph = *Graph::LibGEXFc::GEXF_getUndirectedGraph;
*getDirectedGraph = *Graph::LibGEXFc::GEXF_getDirectedGraph;
*getData = *Graph::LibGEXFc::GEXF_getData;
*getMetaData = *Graph::LibGEXFc::GEXF_getMetaData;
*setGraphType = *Graph::LibGEXFc::GEXF_setGraphType;
*getGraphType = *Graph::LibGEXFc::GEXF_getGraphType;
*initGraphMode = *Graph::LibGEXFc::GEXF_initGraphMode;
*getGraphMode = *Graph::LibGEXFc::GEXF_getGraphMode;
*checkIntegrity = *Graph::LibGEXFc::GEXF_checkIntegrity;
*swig__graph_get = *Graph::LibGEXFc::GEXF__graph_get;
*swig__graph_set = *Graph::LibGEXFc::GEXF__graph_set;
*swig__type_get = *Graph::LibGEXFc::GEXF__type_get;
*swig__type_set = *Graph::LibGEXFc::GEXF__type_set;
*swig__mode_get = *Graph::LibGEXFc::GEXF__mode_get;
*swig__mode_set = *Graph::LibGEXFc::GEXF__mode_set;
*swig__data_get = *Graph::LibGEXFc::GEXF__data_get;
*swig__data_set = *Graph::LibGEXFc::GEXF__data_set;
*swig__meta_get = *Graph::LibGEXFc::GEXF__meta_get;
*swig__meta_set = *Graph::LibGEXFc::GEXF__meta_set;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::AbstractIter ##############

package Graph::LibGEXF::AbstractIter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
*begin = *Graph::LibGEXFc::AbstractIter_begin;
*hasNext = *Graph::LibGEXFc::AbstractIter_hasNext;
*next = *Graph::LibGEXFc::AbstractIter_next;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_AbstractIter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::MemoryValidator ##############

package Graph::LibGEXF::MemoryValidator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_MemoryValidator($self);
        delete $OWNER{$self};
    }
}

*run = *Graph::LibGEXFc::MemoryValidator_run;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::FileReader ##############

package Graph::LibGEXF::FileReader;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
*_1_0 = *Graph::LibGEXFc::FileReader__1_0;
*_1_1 = *Graph::LibGEXFc::FileReader__1_1;
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_FileReader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_FileReader($self);
        delete $OWNER{$self};
    }
}

*getGEXFCopy = *Graph::LibGEXFc::FileReader_getGEXFCopy;
*init = *Graph::LibGEXFc::FileReader_init;
*slurp = *Graph::LibGEXFc::FileReader_slurp;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::AbstractParser ##############

package Graph::LibGEXF::AbstractParser;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
*bind = *Graph::LibGEXFc::AbstractParser_bind;
*processNode = *Graph::LibGEXFc::AbstractParser_processNode;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_AbstractParser($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::GexfParser ##############

package Graph::LibGEXF::GexfParser;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF::AbstractParser Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_GexfParser($self);
        delete $OWNER{$self};
    }
}

*processNode = *Graph::LibGEXFc::GexfParser_processNode;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::LegacyParser ##############

package Graph::LibGEXF::LegacyParser;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF::AbstractParser Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_LegacyParser(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_LegacyParser($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::RngValidator ##############

package Graph::LibGEXF::RngValidator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_RngValidator($self);
        delete $OWNER{$self};
    }
}

*run = *Graph::LibGEXFc::RngValidator_run;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::SchemaValidator ##############

package Graph::LibGEXF::SchemaValidator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_SchemaValidator($self);
        delete $OWNER{$self};
    }
}

*run = *Graph::LibGEXFc::SchemaValidator_run;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::FileWriter ##############

package Graph::LibGEXF::FileWriter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
*NODE = *Graph::LibGEXFc::FileWriter_NODE;
*EDGE = *Graph::LibGEXFc::FileWriter_EDGE;
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_FileWriter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_FileWriter($self);
        delete $OWNER{$self};
    }
}

*getGEXFCopy = *Graph::LibGEXFc::FileWriter_getGEXFCopy;
*init = *Graph::LibGEXFc::FileWriter_init;
*write = *Graph::LibGEXFc::FileWriter_write;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::LegacyWriter ##############

package Graph::LibGEXF::LegacyWriter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
*NODE = *Graph::LibGEXFc::LegacyWriter_NODE;
*EDGE = *Graph::LibGEXFc::LegacyWriter_EDGE;
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_LegacyWriter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_LegacyWriter($self);
        delete $OWNER{$self};
    }
}

*getGEXFCopy = *Graph::LibGEXFc::LegacyWriter_getGEXFCopy;
*init = *Graph::LibGEXFc::LegacyWriter_init;
*write = *Graph::LibGEXFc::LegacyWriter_write;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::Conv ##############

package Graph::LibGEXF::Conv;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_Conv($self);
        delete $OWNER{$self};
    }
}

*xmlCharToId = *Graph::LibGEXFc::Conv_xmlCharToId;
*strToId = *Graph::LibGEXFc::Conv_strToId;
*xmlCharToStr = *Graph::LibGEXFc::Conv_xmlCharToStr;
*xmlCharToUnsignedInt = *Graph::LibGEXFc::Conv_xmlCharToUnsignedInt;
*xmlCharToFloat = *Graph::LibGEXFc::Conv_xmlCharToFloat;
*idToStr = *Graph::LibGEXFc::Conv_idToStr;
*unsignedIntToStr = *Graph::LibGEXFc::Conv_unsignedIntToStr;
*floatToStr = *Graph::LibGEXFc::Conv_floatToStr;
*strToUnsignedInt = *Graph::LibGEXFc::Conv_strToUnsignedInt;
*edgeTypeToStr = *Graph::LibGEXFc::Conv_edgeTypeToStr;
*attrTypeToStr = *Graph::LibGEXFc::Conv_attrTypeToStr;
*isBoolean = *Graph::LibGEXFc::Conv_isBoolean;
*isDouble = *Graph::LibGEXFc::Conv_isDouble;
*isInteger = *Graph::LibGEXFc::Conv_isInteger;
*isFloat = *Graph::LibGEXFc::Conv_isFloat;
*isLong = *Graph::LibGEXFc::Conv_isLong;
*isAnyURI = *Graph::LibGEXFc::Conv_isAnyURI;
*tokenizer = *Graph::LibGEXFc::Conv_tokenizer;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::Graph ##############

package Graph::LibGEXF::Graph;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_Graph(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_Graph($self);
        delete $OWNER{$self};
    }
}

*addNode = *Graph::LibGEXFc::Graph_addNode;
*addEdge = *Graph::LibGEXFc::Graph_addEdge;
*removeNode = *Graph::LibGEXFc::Graph_removeNode;
*removeEdge = *Graph::LibGEXFc::Graph_removeEdge;
*containsNode = *Graph::LibGEXFc::Graph_containsNode;
*containsEdge = *Graph::LibGEXFc::Graph_containsEdge;
*getEdge = *Graph::LibGEXFc::Graph_getEdge;
*getNodes = *Graph::LibGEXFc::Graph_getNodes;
*getEdges = *Graph::LibGEXFc::Graph_getEdges;
*getNeighbors = *Graph::LibGEXFc::Graph_getNeighbors;
*getNodeCount = *Graph::LibGEXFc::Graph_getNodeCount;
*getEdgeCount = *Graph::LibGEXFc::Graph_getEdgeCount;
*getDegree = *Graph::LibGEXFc::Graph_getDegree;
*clear = *Graph::LibGEXFc::Graph_clear;
*clearEdges = *Graph::LibGEXFc::Graph_clearEdges;
*readLock = *Graph::LibGEXFc::Graph_readLock;
*readUnlock = *Graph::LibGEXFc::Graph_readUnlock;
*writeLock = *Graph::LibGEXFc::Graph_writeLock;
*writeUnlock = *Graph::LibGEXFc::Graph_writeUnlock;
*isReadLock = *Graph::LibGEXFc::Graph_isReadLock;
*isWriteLock = *Graph::LibGEXFc::Graph_isWriteLock;
*isUnlock = *Graph::LibGEXFc::Graph_isUnlock;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::DirectedGraph ##############

package Graph::LibGEXF::DirectedGraph;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF::Graph Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_DirectedGraph(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_DirectedGraph($self);
        delete $OWNER{$self};
    }
}

*removeInEdges = *Graph::LibGEXFc::DirectedGraph_removeInEdges;
*removeOutEdges = *Graph::LibGEXFc::DirectedGraph_removeOutEdges;
*getInEdges = *Graph::LibGEXFc::DirectedGraph_getInEdges;
*getOutEdges = *Graph::LibGEXFc::DirectedGraph_getOutEdges;
*getSuccessors = *Graph::LibGEXFc::DirectedGraph_getSuccessors;
*getPredecessors = *Graph::LibGEXFc::DirectedGraph_getPredecessors;
*getInDegree = *Graph::LibGEXFc::DirectedGraph_getInDegree;
*getOutDegree = *Graph::LibGEXFc::DirectedGraph_getOutDegree;
*isSuccessor = *Graph::LibGEXFc::DirectedGraph_isSuccessor;
*isPredecessor = *Graph::LibGEXFc::DirectedGraph_isPredecessor;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::UndirectedGraph ##############

package Graph::LibGEXF::UndirectedGraph;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF::Graph Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_UndirectedGraph(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_UndirectedGraph($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::NodeIter ##############

package Graph::LibGEXF::NodeIter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF::AbstractIter Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_NodeIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_NodeIter($self);
        delete $OWNER{$self};
    }
}

*begin = *Graph::LibGEXFc::NodeIter_begin;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::EdgeIter ##############

package Graph::LibGEXF::EdgeIter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF::AbstractIter Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_EdgeIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_EdgeIter($self);
        delete $OWNER{$self};
    }
}

*begin = *Graph::LibGEXFc::EdgeIter_begin;
*currentSource = *Graph::LibGEXFc::EdgeIter_currentSource;
*currentTarget = *Graph::LibGEXFc::EdgeIter_currentTarget;
*currentProperty = *Graph::LibGEXFc::EdgeIter_currentProperty;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::Data ##############

package Graph::LibGEXF::Data;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_Data(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_Data($self);
        delete $OWNER{$self};
    }
}

*getNodeLabel = *Graph::LibGEXFc::Data_getNodeLabel;
*hasNodeLabel = *Graph::LibGEXFc::Data_hasNodeLabel;
*setNodeLabel = *Graph::LibGEXFc::Data_setNodeLabel;
*getEdgeLabel = *Graph::LibGEXFc::Data_getEdgeLabel;
*hasEdgeLabel = *Graph::LibGEXFc::Data_hasEdgeLabel;
*setEdgeLabel = *Graph::LibGEXFc::Data_setEdgeLabel;
*addNodeAttributeColumn = *Graph::LibGEXFc::Data_addNodeAttributeColumn;
*addEdgeAttributeColumn = *Graph::LibGEXFc::Data_addEdgeAttributeColumn;
*setNodeAttributeDefault = *Graph::LibGEXFc::Data_setNodeAttributeDefault;
*setEdgeAttributeDefault = *Graph::LibGEXFc::Data_setEdgeAttributeDefault;
*setNodeAttributeOptions = *Graph::LibGEXFc::Data_setNodeAttributeOptions;
*setEdgeAttributeOptions = *Graph::LibGEXFc::Data_setEdgeAttributeOptions;
*setNodeValue = *Graph::LibGEXFc::Data_setNodeValue;
*setEdgeValue = *Graph::LibGEXFc::Data_setEdgeValue;
*getNodeAttributeColumn = *Graph::LibGEXFc::Data_getNodeAttributeColumn;
*getEdgeAttributeColumn = *Graph::LibGEXFc::Data_getEdgeAttributeColumn;
*getNodeAttribute = *Graph::LibGEXFc::Data_getNodeAttribute;
*getEdgeAttribute = *Graph::LibGEXFc::Data_getEdgeAttribute;
*getNodeAttributeRow = *Graph::LibGEXFc::Data_getNodeAttributeRow;
*getEdgeAttributeRow = *Graph::LibGEXFc::Data_getEdgeAttributeRow;
*getNodeAttributeDefault = *Graph::LibGEXFc::Data_getNodeAttributeDefault;
*getEdgeAttributeOptions = *Graph::LibGEXFc::Data_getEdgeAttributeOptions;
*getNodeAttributeOptions = *Graph::LibGEXFc::Data_getNodeAttributeOptions;
*getEdgeAttributeDefault = *Graph::LibGEXFc::Data_getEdgeAttributeDefault;
*hasNodeAttributeDefault = *Graph::LibGEXFc::Data_hasNodeAttributeDefault;
*hasEdgeAttributeDefault = *Graph::LibGEXFc::Data_hasEdgeAttributeDefault;
*hasNodeAttributeOptions = *Graph::LibGEXFc::Data_hasNodeAttributeOptions;
*hasEdgeAttributeOptions = *Graph::LibGEXFc::Data_hasEdgeAttributeOptions;
*isNodeAttributeOption = *Graph::LibGEXFc::Data_isNodeAttributeOption;
*isEdgeAttributeOption = *Graph::LibGEXFc::Data_isEdgeAttributeOption;
*removeNodeAttributeColumn = *Graph::LibGEXFc::Data_removeNodeAttributeColumn;
*removeEdgeAttributeColumn = *Graph::LibGEXFc::Data_removeEdgeAttributeColumn;
*clearNodeAttributes = *Graph::LibGEXFc::Data_clearNodeAttributes;
*clearEdgeAttributes = *Graph::LibGEXFc::Data_clearEdgeAttributes;
*clear = *Graph::LibGEXFc::Data_clear;
*clearEdgesAttributes = *Graph::LibGEXFc::Data_clearEdgesAttributes;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::MetaData ##############

package Graph::LibGEXF::MetaData;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_MetaData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_MetaData($self);
        delete $OWNER{$self};
    }
}

*getVersion = *Graph::LibGEXFc::MetaData_getVersion;
*getXmlns = *Graph::LibGEXFc::MetaData_getXmlns;
*getXsi = *Graph::LibGEXFc::MetaData_getXsi;
*getSchema = *Graph::LibGEXFc::MetaData_getSchema;
*getVariant = *Graph::LibGEXFc::MetaData_getVariant;
*getCreator = *Graph::LibGEXFc::MetaData_getCreator;
*getDescription = *Graph::LibGEXFc::MetaData_getDescription;
*getKeywords = *Graph::LibGEXFc::MetaData_getKeywords;
*getLastModifiedDate = *Graph::LibGEXFc::MetaData_getLastModifiedDate;
*setVersion = *Graph::LibGEXFc::MetaData_setVersion;
*setXmlns = *Graph::LibGEXFc::MetaData_setXmlns;
*setXsi = *Graph::LibGEXFc::MetaData_setXsi;
*setSchema = *Graph::LibGEXFc::MetaData_setSchema;
*setVariant = *Graph::LibGEXFc::MetaData_setVariant;
*setCreator = *Graph::LibGEXFc::MetaData_setCreator;
*setDescription = *Graph::LibGEXFc::MetaData_setDescription;
*setKeywords = *Graph::LibGEXFc::MetaData_setKeywords;
*setLastModifiedDate = *Graph::LibGEXFc::MetaData_setLastModifiedDate;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::AttributeIter ##############

package Graph::LibGEXF::AttributeIter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF::AbstractIter Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
*NODE = *Graph::LibGEXFc::AttributeIter_NODE;
*EDGE = *Graph::LibGEXFc::AttributeIter_EDGE;
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_AttributeIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_AttributeIter($self);
        delete $OWNER{$self};
    }
}

*begin = *Graph::LibGEXFc::AttributeIter_begin;
*currentTitle = *Graph::LibGEXFc::AttributeIter_currentTitle;
*currentType = *Graph::LibGEXFc::AttributeIter_currentType;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Graph::LibGEXF::AttValueIter ##############

package Graph::LibGEXF::AttValueIter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Graph::LibGEXF::AbstractIter Graph::LibGEXF );
%OWNER = ();
%ITERATORS = ();
*NODE = *Graph::LibGEXFc::AttValueIter_NODE;
*EDGE = *Graph::LibGEXFc::AttValueIter_EDGE;
sub new {
    my $pkg = shift;
    my $self = Graph::LibGEXFc::new_AttValueIter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Graph::LibGEXFc::delete_AttValueIter($self);
        delete $OWNER{$self};
    }
}

*begin = *Graph::LibGEXFc::AttValueIter_begin;
*currentValue = *Graph::LibGEXFc::AttValueIter_currentValue;
*currentName = *Graph::LibGEXFc::AttValueIter_currentName;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Graph::LibGEXF;

*GRAPH_UNDEF = *Graph::LibGEXFc::GRAPH_UNDEF;
*GRAPH_DIRECTED = *Graph::LibGEXFc::GRAPH_DIRECTED;
*GRAPH_UNDIRECTED = *Graph::LibGEXFc::GRAPH_UNDIRECTED;
*GRAPH_MIXED = *Graph::LibGEXFc::GRAPH_MIXED;
*EDGE_TYPE = *Graph::LibGEXFc::EDGE_TYPE;
*EDGE_WEIGHT = *Graph::LibGEXFc::EDGE_WEIGHT;
*EDGE_UNDEF = *Graph::LibGEXFc::EDGE_UNDEF;
*EDGE_DIRECTED = *Graph::LibGEXFc::EDGE_DIRECTED;
*EDGE_UNDIRECTED = *Graph::LibGEXFc::EDGE_UNDIRECTED;
*EDGE_MUTUAL = *Graph::LibGEXFc::EDGE_MUTUAL;
*INTEGER = *Graph::LibGEXFc::INTEGER;
*DOUBLE = *Graph::LibGEXFc::DOUBLE;
*FLOAT = *Graph::LibGEXFc::FLOAT;
*LONG = *Graph::LibGEXFc::LONG;
*BOOLEAN = *Graph::LibGEXFc::BOOLEAN;
*STRING = *Graph::LibGEXFc::STRING;
*LISTSTRING = *Graph::LibGEXFc::LISTSTRING;
*ANYURI = *Graph::LibGEXFc::ANYURI;
use version;
our $VERSION = '0.01';
1;
__END__

=encoding utf8

=head1 NAME

Graph::LibGEXF -

=head1 SYNOPSIS

  use Graph::LibGEXF;

=head1 DESCRIPTION

Graph::LibGEXF is

=head1 AUTHOR

sebastien heymann E<lt>sebastien.heymann@gephi.orgE<gt>

=head1 SEE ALSO

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
